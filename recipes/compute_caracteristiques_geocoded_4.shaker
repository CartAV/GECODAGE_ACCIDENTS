{
  "explorationFilters": [],
  "maxProcessedMemTableBytes": -1,
  "analysisColumnData": {},
  "columnsSelection": {
    "mode": "ALL"
  },
  "globalSearchQuery": "",
  "vizSampling": {
    "_refreshTrigger": 0,
    "autoRefreshSample": false
  },
  "origin": "PREPARE_RECIPE",
  "sorting": [],
  "coloring": {
    "individualColumns": [],
    "scheme": "MEANING_AND_STATUS",
    "valueColoringMode": "HASH"
  },
  "steps": [
    {
      "alwaysShowComment": false,
      "preview": false,
      "params": {
        "usePythonUnicode": true,
        "stopOnError": true,
        "pythonSourceCode": "def process(row):\n    if row[\"distance_commune_baac\"] and float(row[\"distance_commune_baac\"]) \u003e 2000:\n        row[\"baac_score\"] \u003d 0.0\n    elif row[\"long\"]:\n        row[\"baac_score\"] \u003d 1.0\n    if row[\"distance_commune_ban\"] and float(row[\"distance_commune_ban\"]) \u003e 1000:\n        row[\"ban_score\"] \u003d 0.0\n    if row[\"distance_commune_ban2\"] and float(row[\"distance_commune_ban2\"]) \u003e 1000:\n        row[\"ban2_score\"] \u003d 0.0\n    if row[\"distance_commune_bano\"] and float(row[\"distance_commune_bano\"]) \u003e 1000:\n        row[\"bano_score\"] \u003d 0.0\n    return row",
        "mode": "ROW"
      },
      "type": "PythonUDF",
      "disabled": false,
      "metaType": "PROCESSOR"
    },
    {
      "alwaysShowComment": false,
      "preview": true,
      "params": {
        "usePythonUnicode": true,
        "stopOnError": true,
        "pythonSourceCode": "# Score minimal pour être pris en compte\nmin_score \u003d 0.5\n\n# commentaire de Francis : cette fonction n\u0027est pas appelée ?\ndef process(row):\n    if row[\"baac_score\"]:\n        baac_score \u003d float(row[\"baac_score\"])\n    else:\n        baac_score \u003d None\n    if row[\"ban_score\"]:\n        ban_score \u003d float(row[\"ban_score\"])\n    else:\n        ban_score \u003d None\n    if row[\"bano_score\"]:\n        bano_score \u003d float(row[\"bano_score\"])\n    else:\n        bano_score \u003d None     \n    if row[\"ban2_score\"]:\n        ban2_score \u003d float(row[\"ban2_score\"])\n    else:\n        ban2_score \u003d None\n    \n    # Si on a des coordonnées saisies dès la BAAC\n    if row[\"long\"] and row[\"lat\"]:\n        # Si le score est bon, et qu’il s’agit d’un pas de porte,\n        # On préfère le résultat de la BAN\n        if ban_score \u003e 0.6 and row[\"ban_type\"] \u003d\u003d \"housenumber\":\n            row[\"longitude\"] \u003d row[\"ban_longitude\"]\n            row[\"latitude\"] \u003d row[\"ban_latitude\"]\n            row[\"geo_source\"] \u003d \"ban + citycode\"\n            row[\"geo_type\"] \u003d row[\"ban_type\"]\n            row[\"geo_score\"] \u003d row[\"ban_score\"]\n        # Sinon on préfère les coordonnées saisies\n        elif baac_score \u003e min_score:\n            row[\"longitude\"] \u003d row[\"long\"]\n            row[\"latitude\"] \u003d row[\"lat\"]\n            row[\"geo_source\"] \u003d \"baac\"\n            row[\"geo_type\"] \u003d \"unknown\"\n    \n    # Pas de géocodage saisi dans la baac\n    elif max(ban_score, bano_score, ban2_score) \u003e\u003d min_score:\n        # On récupère simplement celui qui a le plus gros score\n        if ban_score \u003e\u003d bano_score and ban_score \u003e\u003d ban2_score:\n            row[\"longitude\"] \u003d row[\"ban_longitude\"]\n            row[\"latitude\"] \u003d row[\"ban_latitude\"]\n            row[\"geo_source\"] \u003d \"ban + citycode\"\n            row[\"geo_type\"] \u003d row[\"ban_type\"]\n            row[\"geo_score\"] \u003d row[\"ban_score\"]\n        elif bano_score \u003e ban_score and bano_score \u003e ban2_score:\n            row[\"longitude\"] \u003d row[\"bano_longitude\"]\n            row[\"latitude\"] \u003d row[\"bano_latitude\"]\n            row[\"geo_source\"] \u003d \"bano + name\"\n            row[\"geo_type\"] \u003d row[\"bano_type\"]\n            row[\"geo_score\"] \u003d row[\"bano_score\"]\n        elif ban2_score \u003e ban_score and ban2_score \u003e bano_score:\n            row[\"longitude\"] \u003d row[\"ban2_longitude\"]\n            row[\"latitude\"] \u003d row[\"ban2_latitude\"]\n            row[\"geo_source\"] \u003d \"ban + name\"\n            row[\"geo_type\"] \u003d row[\"ban2_type\"]\n            row[\"geo_score\"] \u003d row[\"ban2_score\"]\n        \n    return row\n",
        "mode": "ROW"
      },
      "type": "PythonUDF",
      "disabled": false,
      "metaType": "PROCESSOR"
    }
  ],
  "exploreUIParams": {
    "autoRefresh": true
  },
  "previewMode": "ALL_ROWS",
  "explorationSampling": {
    "_refreshTrigger": 0,
    "autoRefreshSample": false,
    "selection": {
      "targetRatio": 0.02,
      "maxRecords": 10000,
      "maxStoredBytes": -1,
      "partitionSelectionMethod": "ALL",
      "withinFirstN": -1,
      "samplingMethod": "HEAD_SEQUENTIAL",
      "latestPartitionsN": 1,
      "maxReadUncompressedBytes": -1,
      "filter": {
        "enabled": false,
        "distinct": false
      }
    }
  }
}